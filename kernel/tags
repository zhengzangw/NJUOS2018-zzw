!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AM_HOME	Makefile	/^export AM_HOME := $(PWD)\/..\/abstract-machine$/;"	m
ARCH	Makefile	/^export ARCH := x86-qemu$/;"	m
Assert	include/debug.h	39;"	d
Assert	include/debug.h	48;"	d
BIAS	include/pmm.h	18;"	d
CREATE	src/devices/dev.c	43;"	d	file:
DEVICES	src/devices/dev.c	6;"	d	file:
DEV_CNT	src/devices/dev.c	16;"	d	file:
INC_DIR	Makefile	/^INC_DIR        := include\/ framework\/$/;"	m
INIT	src/devices/dev.c	46;"	d	file:
INT_MAX	include/kmt.h	13;"	d
INT_MIN	include/kmt.h	14;"	d
LENGTH	include/devices.h	5;"	d
Log	include/debug.h	21;"	d
Log	include/debug.h	24;"	d
Log	include/debug.h	28;"	d
Logcontext	include/debug.h	65;"	d
Logcpu	include/debug.h	18;"	d
Logint	include/debug.h	36;"	d
Logintr	include/debug.h	62;"	d
Loglock	include/debug.h	63;"	d
Lognode	include/debug.h	57;"	d
Logsem	include/debug.h	68;"	d
MAXCB	include/os.h	9;"	d
MAXCPU	include/kmt.h	7;"	d
MAXTASK	include/kmt.h	12;"	d
MODULE	framework/kernel.h	/^} MODULE(dev);$/;"	t	typeref:struct:__anon4
MODULE	framework/kernel.h	/^} MODULE(kmt);$/;"	t	typeref:struct:__anon3
MODULE	framework/kernel.h	/^} MODULE(os);$/;"	t	typeref:struct:__anon1
MODULE	framework/kernel.h	/^} MODULE(pmm);$/;"	t	typeref:struct:__anon2
MODULE	framework/kernel.h	7;"	d
MODULE_DEF	framework/kernel.h	10;"	d
MODULE_DEF	src/devices/dev.c	/^MODULE_DEF(dev) {$/;"	f
MODULE_DEF	src/kmt.c	/^MODULE_DEF(kmt){$/;"	f
MODULE_DEF	src/os.c	/^MODULE_DEF(os){$/;"	f
MODULE_DEF	src/pmm.c	/^MODULE_DEF(pmm) {$/;"	f
NAME	Makefile	/^NAME           := kernel$/;"	m
NEVENTS	src/devices/input/input.c	3;"	d	file:
NSPRITE	src/devices/video/video.c	4;"	d	file:
NTEXTURE	src/devices/video/video.c	3;"	d	file:
PREBUILD	Makefile	/^PREBUILD := git initrd$/;"	m
Panic	include/debug.h	51;"	d
QEMU_FLAGS	Makefile	/^QEMU_FLAGS := -serial stdio -machine accel=kvm:tcg -drive format=raw,file=$(BINARY)$/;"	m
QEMU_FLAGS_TCG	Makefile	/^QEMU_FLAGS_TCG := -serial stdio -machine accel=tcg -drive format=raw,file=$(BINARY)$/;"	m
RD_SIZE	include/devices.h	36;"	d
SHOULD_NOT_REACH_HERE	include/debug.h	54;"	d
SPRITE_BRK	include/devices.h	58;"	d
SRCS	Makefile	/^SRCS           := framework\/main.c $(shell find -L .\/src\/ -name "*.c" -o -name "*.S")$/;"	m
STACKSIZE	include/kmt.h	11;"	d
TERM_FONT	include/devices.h	106;"	d
TEXTURE_H	include/devices.h	57;"	d
TEXTURE_W	include/devices.h	56;"	d
TODO	include/debug.h	53;"	d
TTY_COOK_BUF_SZ	src/devices/tty/tty.c	3;"	d	file:
Tasknode	include/kmt.h	/^typedef struct Tasknode {$/;"	s
__COMMON_H__	include/common.h	2;"	d
__DEBUG_H__	include/debug.h	2;"	d
__KERNEL_H__	framework/kernel.h	2;"	d
__KMT_H__	include/kmt.h	2;"	d
__LIST_H__	include/pmm.h	2;"	d
__NANOS_H__	framework/nanos.h	2;"	d
add_node	src/pmm.c	/^void *add_node(struct node *p, size_t size) {$/;"	f
alloc	framework/kernel.h	/^  void *(*alloc)(size_t size);$/;"	m	struct:__anon2
alloc_lock	src/pmm.c	/^spinlock_t alloc_lock;$/;"	v
alt	include/devices.h	/^  uint32_t ctrl: 1, alt: 1;$/;"	m	struct:input_event
alt_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon5
assertIF0	include/debug.h	60;"	d
assertIF1	include/debug.h	61;"	d
buf	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
buf	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon8	typeref:struct:__anon8::character
callback	include/os.h	/^typedef struct callback {$/;"	s
callback_t	include/os.h	/^} callback_t;$/;"	t	typeref:struct:callback
capslock	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon5
ch	include/devices.h	/^  unsigned char ch;$/;"	m	struct:character
character	include/devices.h	/^struct character {$/;"	s
cnt_tasks	include/kmt.h	/^  int count, cnt_tasks;$/;"	m	struct:semaphore
cnt_tasks	src/kmt.c	/^int cnt_tasks;            \/\/ total created tasks$/;"	v
columns	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon8
consumer	framework/test_pc.c	/^void consumer(){$/;"	f
context	include/kmt.h	/^  _Context context;$/;"	m	struct:task
cooked	include/devices.h	/^  sem_t lock, cooked;$/;"	m	struct:__anon8
count	include/kmt.h	/^  int count, cnt_tasks;$/;"	m	struct:semaphore
cpu	include/kmt.h	/^  int cpu;$/;"	m	struct:spinlock
cpudefaulttask	src/kmt.c	/^task_t cpudefaulttask[MAXCPU];$/;"	v
cpuncli	src/kmt.c	/^int cpuncli[MAXCPU], intena[MAXCPU];$/;"	v
cputask	src/kmt.c	/^task_t *cputask[MAXCPU];  \/\/ task running on each cpu$/;"	v
cputask_last	src/kmt.c	/^task_t *cputask_last[MAXCPU];$/;"	v
create	framework/kernel.h	/^  int (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);$/;"	m	struct:__anon3
ctrl	include/devices.h	/^  uint32_t ctrl: 1, alt: 1;$/;"	m	struct:input_event
ctrl_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon5
current	include/devices.h	/^  uint32_t current;$/;"	m	struct:display_info
cursor	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon8	typeref:struct:__anon8::
customer	framework/test_tty_pc.c	/^void customer(void *arg) {$/;"	f
data	include/devices.h	/^  uint32_t data: 16;$/;"	m	struct:input_event
delete_node	src/pmm.c	/^void delete_node(struct node *p) {$/;"	f
dev_create	src/devices/dev.c	/^static device_t *dev_create(size_t dev_size, const char* dev_name, int dev_id, devops_t *dev_ops) {$/;"	f	file:
dev_init	src/devices/dev.c	/^static void dev_init() {$/;"	f	file:
dev_lookup	src/devices/dev.c	/^device_t *dev_lookup(const char *name) {$/;"	f
device	include/devices.h	/^struct device {$/;"	s
device_t	framework/kernel.h	/^typedef struct device device_t;$/;"	t	typeref:struct:device
devices	src/devices/dev.c	/^device_t *devices[0 DEVICES(DEV_CNT)];$/;"	v
devops	framework/kernel.h	/^typedef struct devops {$/;"	s
devops_t	framework/kernel.h	/^} devops_t;$/;"	t	typeref:struct:devops
dirty	include/devices.h	/^  uint8_t *dirty;$/;"	m	struct:__anon8
display	include/devices.h	/^  device_t *fbdev; int display;$/;"	m	struct:__anon8
display	include/devices.h	/^  unsigned int display: 4;$/;"	m	struct:sprite
display_info	include/devices.h	/^struct display_info {$/;"	s
echo_task	src/devices/tty/tty.c	/^void echo_task(void *name){$/;"	f
empty	framework/test_pc.c	/^sem_t empty, fill;$/;"	v
end	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
end	include/devices.h	/^  char *start, *end;$/;"	m	struct:__anon6
end	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon8	typeref:struct:__anon8::
end	include/pmm.h	/^  uintptr_t start, end;$/;"	m	struct:node
event	include/os.h	/^    int event;$/;"	m	struct:callback
event	src/devices/input/input.c	/^static struct input_event event(int ctrl, int alt, int data) {$/;"	f	file:
event_sem	include/devices.h	/^  sem_t event_sem;$/;"	m	struct:__anon5
events	include/devices.h	/^  struct input_event *events;$/;"	m	struct:__anon5	typeref:struct:__anon5::input_event
fb_init	src/devices/video/video.c	/^int fb_init(device_t *dev) {$/;"	f
fb_ops	src/devices/video/video.c	/^devops_t fb_ops = {$/;"	v
fb_read	src/devices/video/video.c	/^ssize_t fb_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
fb_sem	src/devices/video/video.c	/^static sem_t fb_sem;$/;"	v	file:
fb_t	include/devices.h	/^} fb_t;$/;"	t	typeref:struct:__anon7
fb_write	src/devices/video/video.c	/^ssize_t fb_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
fbdev	include/devices.h	/^  device_t *fbdev; int display;$/;"	m	struct:__anon8
fill	framework/test_pc.c	/^sem_t empty, fill;$/;"	v
font_default	src/devices/video/fonts/default.c	/^unsigned char font_default[] = {$/;"	v
font_load	src/devices/video/video.c	/^static void font_load(fb_t *fb, uint8_t *font) {$/;"	f	file:
font_sans	src/devices/video/fonts/sans.c	/^unsigned char font_sans[] = {$/;"	v
font_serif	src/devices/video/fonts/serif.c	/^unsigned char font_serif[] = {$/;"	v
free	framework/kernel.h	/^  void (*free)(void *ptr);$/;"	m	struct:__anon2
front	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
front	include/devices.h	/^  int front, rear;$/;"	m	struct:__anon5
h_handlers	src/os.c	/^int h_handlers;$/;"	v
handler	include/os.h	/^    handler_t handler;$/;"	m	struct:callback
handler_t	framework/kernel.h	/^typedef _Context *(*handler_t)(_Event, _Context *);$/;"	t
handlers	src/os.c	/^callback_t handlers[MAXCB];$/;"	v
head	include/pmm.h	/^struct node *head, *tail;$/;"	v	typeref:struct:node
head	src/kmt.c	188;"	d	file:
height	include/devices.h	/^  uint32_t width, height;$/;"	m	struct:display_info
holding	src/kmt.c	/^static int holding(spinlock_t *lock) {$/;"	f	file:
id	include/devices.h	/^  int id;$/;"	m	struct:device
id	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
info	include/devices.h	/^  struct display_info *info;$/;"	m	struct:__anon7	typeref:struct:__anon7::display_info
init	framework/kernel.h	/^  int (*init)(device_t *dev);$/;"	m	struct:devops
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon1
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon2
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon3
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon4
initrd_end	src/devices/ramdisk/initrd.S	/^initrd_end:/;"	l
initrd_start	src/devices/ramdisk/initrd.S	/^initrd_start:$/;"	l
input_event	include/devices.h	/^struct input_event {$/;"	s
input_init	src/devices/input/input.c	/^static int input_init(device_t *dev) {$/;"	f	file:
input_keydown	src/devices/input/input.c	/^void input_keydown(device_t *dev, int code) {$/;"	f
input_notify	src/devices/input/input.c	/^static _Context *input_notify(_Event ev, _Context *context) {$/;"	f	file:
input_ops	src/devices/input/input.c	/^devops_t input_ops = {$/;"	v
input_read	src/devices/input/input.c	/^static ssize_t input_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f	file:
input_t	include/devices.h	/^} input_t;$/;"	t	typeref:struct:__anon5
input_task	src/devices/input/input.c	/^void input_task(void *args) {$/;"	f
input_write	src/devices/input/input.c	/^static ssize_t input_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f	file:
intena	src/kmt.c	/^int cpuncli[MAXCPU], intena[MAXCPU];$/;"	v
kalloc	src/pmm.c	/^static void *kalloc(size_t size) {$/;"	f	file:
keymap	src/devices/input/keymaps.c	/^char keymap[256] = {$/;"	v
keymap_shift	src/devices/input/keymaps.c	/^char keymap_shift[256] = {$/;"	v
kfree	src/pmm.c	/^static void kfree(void *ptr) {$/;"	f	file:
kmt_context_save	src/kmt.c	/^_Context *kmt_context_save(_Event ev, _Context *context) {$/;"	f
kmt_context_switch	src/kmt.c	/^_Context *kmt_context_switch(_Event ev, _Context *context) {$/;"	f
kmt_create	src/kmt.c	/^int kmt_create(task_t *task, const char *name, void (*entry)(void *arg),$/;"	f
kmt_init	src/kmt.c	/^void kmt_init() {$/;"	f
kmt_teardown	src/kmt.c	/^void kmt_teardown(task_t *task) {$/;"	f
lines	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon8
list_init	src/pmm.c	/^void list_init(uintptr_t pm_start, uintptr_t pm_end) {$/;"	f
lock	include/devices.h	/^  sem_t lock, cooked;$/;"	m	struct:__anon8
lock	include/devices.h	/^  spinlock_t lock;$/;"	m	struct:__anon5
lock	include/kmt.h	/^  spinlock_t lock;$/;"	m	struct:semaphore
lock_debug	src/os.c	/^spinlock_t lock_debug;$/;"	v
lock_kmt	src/kmt.c	/^spinlock_t lock_kmt;$/;"	v
lock_os	src/os.c	/^spinlock_t lock_os;$/;"	v
lock_print	src/os.c	/^spinlock_t lock_print;$/;"	v
locked	include/kmt.h	/^  int locked;$/;"	m	struct:spinlock
logging	framework/test_abc.c	/^void logging(void *arg) {$/;"	f
logging	framework/test_gen.c	/^void logging(void *arg) {$/;"	f
lprintf	include/common.h	11;"	d
main	framework/main.c	/^int main() {$/;"	f
main	framework/test_abc.c	/^int main() {$/;"	f
main	framework/test_gen.c	/^int main() {$/;"	f
main	framework/test_pc.c	/^int main() {$/;"	f
main	framework/test_tty.c	/^int main() {$/;"	f
main	framework/test_tty_pc.c	/^int main() {$/;"	f
main	framework/test_yield.c	/^int main() {$/;"	f
metadata	include/devices.h	/^  uint32_t metadata;$/;"	m	struct:character
mutex	framework/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
name	include/devices.h	/^  const char *name;$/;"	m	struct:device
name	include/kmt.h	/^  const char *name;$/;"	m	struct:semaphore
name	include/kmt.h	/^  const char *name;$/;"	m	struct:spinlock
name	include/kmt.h	/^  const char *name;$/;"	m	struct:task
next	include/pmm.h	/^  struct node *next, *pre;$/;"	m	struct:node	typeref:struct:node::node
node	include/pmm.h	/^struct node {$/;"	s
non	framework/test_yield.c	/^void non(){$/;"	f
notdefault	src/kmt.c	/^int notdefault[MAXCPU];$/;"	v
num_displays	include/devices.h	/^  uint32_t num_displays;$/;"	m	struct:display_info
num_sprites	include/devices.h	/^  uint32_t num_textures, num_sprites;$/;"	m	struct:display_info
num_textures	include/devices.h	/^  uint32_t num_textures, num_sprites;$/;"	m	struct:display_info
nxt	include/kmt.h	/^  struct Tasknode *nxt, *pre;$/;"	m	struct:Tasknode	typeref:struct:Tasknode::Tasknode
off_t	framework/nanos.h	/^typedef intptr_t off_t;$/;"	t
on_irq	framework/kernel.h	/^  void (*on_irq)(int seq, int event, handler_t handler);$/;"	m	struct:__anon1
ops	include/devices.h	/^  devops_t *ops;$/;"	m	struct:device
os_init	src/os.c	/^static void os_init() {$/;"	f	file:
os_on_irq	src/os.c	/^static void os_on_irq(int seq, int event, handler_t handler) {$/;"	f	file:
os_run	src/os.c	/^static void os_run() {$/;"	f	file:
os_trap	src/os.c	/^static _Context *os_trap(_Event ev, _Context *context) {$/;"	f	file:
panic	include/devices.h	/^static inline void panic(const char *s) { printf("%s\\n", s); _halt(1); }$/;"	f
pcb	include/kmt.h	/^  tasknode_t *pcb;$/;"	m	struct:semaphore
pid_t	framework/nanos.h	/^typedef int32_t pid_t;$/;"	t
pixels	include/devices.h	/^  uint32_t pixels[TEXTURE_W * TEXTURE_H];$/;"	m	struct:texture
pm_end	src/pmm.c	/^static uintptr_t pm_start, pm_end;$/;"	v	file:
pm_start	src/pmm.c	/^static uintptr_t pm_start, pm_end;$/;"	v	file:
pmm_init	src/pmm.c	/^static void pmm_init() {$/;"	f	file:
pop_event	src/devices/input/input.c	/^static struct input_event pop_event(input_t *in) {$/;"	f	file:
popcli	src/kmt.c	/^static void popcli(void) {$/;"	f	file:
pre	include/kmt.h	/^  struct Tasknode *nxt, *pre;$/;"	m	struct:Tasknode	typeref:struct:Tasknode::
pre	include/pmm.h	/^  struct node *next, *pre;$/;"	m	struct:node	typeref:struct:node::
producer	framework/test_pc.c	/^void producer(){$/;"	f
producer	framework/test_tty_pc.c	/^void producer(void *arg) {$/;"	f
ptr	include/devices.h	/^  void *ptr;$/;"	m	struct:device
push_event	src/devices/input/input.c	/^static void push_event(input_t *in, struct input_event ev) {$/;"	f	file:
pushcli	src/kmt.c	/^static void pushcli(void) {$/;"	f	file:
queue	include/devices.h	/^  struct tty_queue queue;$/;"	m	struct:__anon8	typeref:struct:__anon8::tty_queue
rd_init	src/devices/ramdisk/ramdisk.c	/^int rd_init(device_t *dev) {$/;"	f
rd_ops	src/devices/ramdisk/ramdisk.c	/^devops_t rd_ops = {$/;"	v
rd_read	src/devices/ramdisk/ramdisk.c	/^ssize_t rd_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
rd_t	include/devices.h	/^} rd_t;$/;"	t	typeref:struct:__anon6
rd_write	src/devices/ramdisk/ramdisk.c	/^ssize_t rd_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
read	framework/kernel.h	/^  ssize_t (*read)(device_t *dev, off_t offset, void *buf, size_t count);$/;"	m	struct:devops
rear	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
rear	include/devices.h	/^  int front, rear;$/;"	m	struct:__anon5
run	framework/kernel.h	/^  void (*run)();$/;"	m	struct:__anon1
run	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
sem_c	framework/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
sem_init	framework/kernel.h	/^  void (*sem_init)(sem_t *sem, const char *name, int value);$/;"	m	struct:__anon3
sem_init	src/kmt.c	/^void sem_init(sem_t *sem, const char *name, int value) {$/;"	f
sem_kbdirq	src/devices/input/input.c	/^sem_t sem_kbdirq;$/;"	v
sem_list_add	src/kmt.c	/^void sem_list_add(sem_t *sem, task_t *task) {$/;"	f
sem_list_delete	src/kmt.c	/^void sem_list_delete(sem_t *sem) {$/;"	f
sem_p	framework/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
sem_signal	framework/kernel.h	/^  void (*sem_signal)(sem_t *sem);$/;"	m	struct:__anon3
sem_signal	src/kmt.c	/^void sem_signal(sem_t *sem) {$/;"	f
sem_t	framework/kernel.h	/^typedef struct semaphore sem_t;$/;"	t	typeref:struct:semaphore
sem_wait	framework/kernel.h	/^  void (*sem_wait)(sem_t *sem);$/;"	m	struct:__anon3
sem_wait	src/kmt.c	/^void sem_wait(sem_t *sem) {$/;"	f
semaphore	include/kmt.h	/^struct semaphore {$/;"	s
seq	include/os.h	/^    int seq;$/;"	m	struct:callback
shift_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon5
size	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon8
sleep	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
spin_init	framework/kernel.h	/^  void (*spin_init)(spinlock_t *lk, const char *name);$/;"	m	struct:__anon3
spin_init	src/kmt.c	/^void spin_init(spinlock_t *lk, const char *name) {$/;"	f
spin_lock	framework/kernel.h	/^  void (*spin_lock)(spinlock_t *lk);$/;"	m	struct:__anon3
spin_lock	src/kmt.c	/^void spin_lock(spinlock_t *lk) {$/;"	f
spin_unlock	framework/kernel.h	/^  void (*spin_unlock)(spinlock_t *lk);$/;"	m	struct:__anon3
spin_unlock	src/kmt.c	/^void spin_unlock(spinlock_t *lk) {$/;"	f
spinlock	include/kmt.h	/^struct spinlock {$/;"	s
spinlock_t	framework/kernel.h	/^typedef struct spinlock spinlock_t;$/;"	t	typeref:struct:spinlock
sprite	include/devices.h	/^struct sprite {$/;"	s
sprites	include/devices.h	/^  struct sprite *sprites;$/;"	m	struct:__anon7	typeref:struct:__anon7::sprite
ssize_t	framework/nanos.h	/^typedef intptr_t ssize_t;$/;"	t
stack	include/kmt.h	/^  char* stack;$/;"	m	struct:task
start	include/devices.h	/^  char *start, *end;$/;"	m	struct:__anon6
start	include/pmm.h	/^  uintptr_t start, end;$/;"	m	struct:node
start	src/pmm.c	/^static uintptr_t start;$/;"	v	file:
str	framework/test_gen.c	/^char* str[] = {"1", "2", "3", "4"};$/;"	v
tail	include/pmm.h	/^struct node *head, *tail;$/;"	v	typeref:struct:
task	include/kmt.h	/^  task_t *task;$/;"	m	struct:Tasknode
task	include/kmt.h	/^struct task {$/;"	s
task_t	framework/kernel.h	/^typedef struct task task_t;$/;"	t	typeref:struct:task
tasknode_t	include/kmt.h	/^} tasknode_t;$/;"	t	typeref:struct:Tasknode
tasks	src/kmt.c	/^task_t *tasks[MAXTASK];$/;"	v
teardown	framework/kernel.h	/^  void (*teardown)(task_t *task);$/;"	m	struct:__anon3
test	framework/test_gen.c	/^void test(void *arg){$/;"	f
texture	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
texture	include/devices.h	/^struct texture {$/;"	s
texture_fill	src/devices/video/video.c	/^static void texture_fill(struct texture *tx, int top, uint8_t *bits, uint32_t fg, uint32_t bg) {$/;"	f	file:
textures	include/devices.h	/^  struct texture *textures;$/;"	m	struct:__anon7	typeref:struct:__anon7::texture
trap	framework/kernel.h	/^  _Context *(*trap)(_Event ev, _Context *context);$/;"	m	struct:__anon1
tty_cook	src/devices/tty/tty.c	/^static int tty_cook(tty_t *tty, char ch) {$/;"	f	file:
tty_defaultch	src/devices/tty/tty.c	/^struct character tty_defaultch() {$/;"	f
tty_enqueue	src/devices/tty/tty.c	/^static void tty_enqueue(struct tty_queue *q, char ch) {$/;"	f	file:
tty_init	src/devices/tty/tty.c	/^int tty_init(device_t *dev) {$/;"	f
tty_mark	src/devices/tty/tty.c	/^static void tty_mark(tty_t *tty, struct character *ch) {$/;"	f	file:
tty_mark_all	src/devices/tty/tty.c	/^static void tty_mark_all(tty_t *tty) {$/;"	f	file:
tty_mark_line	src/devices/tty/tty.c	/^static void tty_mark_line(tty_t *tty, struct character *ch) {$/;"	f	file:
tty_ops	src/devices/tty/tty.c	/^devops_t tty_ops = {$/;"	v
tty_pop_back	src/devices/tty/tty.c	/^static int tty_pop_back(struct tty_queue *q) {$/;"	f	file:
tty_putc	src/devices/tty/tty.c	/^static void tty_putc(tty_t *tty, char ch) {$/;"	f	file:
tty_queue	include/devices.h	/^struct tty_queue {$/;"	s
tty_read	src/devices/tty/tty.c	/^ssize_t tty_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
tty_render	src/devices/tty/tty.c	/^static void tty_render(tty_t *tty) {$/;"	f	file:
tty_t	include/devices.h	/^} tty_t;$/;"	t	typeref:struct:__anon8
tty_task	src/devices/tty/tty.c	/^void tty_task(void *arg) {$/;"	f
tty_upd_backsp	src/devices/tty/tty.c	/^static inline void tty_upd_backsp(tty_t *tty) {$/;"	f	file:
tty_upd_cr	src/devices/tty/tty.c	/^static inline void tty_upd_cr(tty_t *tty) {$/;"	f	file:
tty_upd_lf	src/devices/tty/tty.c	/^static inline void tty_upd_lf(tty_t *tty) {$/;"	f	file:
tty_upd_putc	src/devices/tty/tty.c	/^static inline void tty_upd_putc(tty_t *tty, char ch) {$/;"	f	file:
tty_upd_scrollup	src/devices/tty/tty.c	/^static void tty_upd_scrollup(tty_t *tty) {$/;"	f	file:
tty_write	src/devices/tty/tty.c	/^ssize_t tty_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
uint	include/debug.h	/^typedef unsigned int uint;$/;"	t
warning	include/common.h	15;"	d
width	include/devices.h	/^  uint32_t width, height;$/;"	m	struct:display_info
write	framework/kernel.h	/^  ssize_t (*write)(device_t *dev, off_t offset, const void *buf, size_t count);$/;"	m	struct:devops
x	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
y	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
z	include/devices.h	/^  unsigned int z: 12;$/;"	m	struct:sprite
