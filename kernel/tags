!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AM_HOME	Makefile	/^export AM_HOME := $(PWD)\/..\/abstract-machine$/;"	m
ARCH	Makefile	/^export ARCH := x86-qemu$/;"	m
Assert	include/debug.h	39;"	d
Assert	include/debug.h	48;"	d
BIAS	include/pmm.h	18;"	d
BLOCK	include/vfs.h	123;"	d
BLOCK_BYTES	include/vfs.h	121;"	d
BLOCK_COVER	src/filesystems/ext2ops.c	182;"	d	file:
CREATE	src/devices/dev.c	44;"	d	file:
DATA	include/vfs.h	125;"	d
DATA_B	include/vfs.h	130;"	d
DEBUG	include/debug.h	6;"	d
DEVICES	src/devices/dev.c	6;"	d	file:
DEV_CNT	src/devices/dev.c	16;"	d	file:
DMAP	include/vfs.h	127;"	d
DR	include/vfs.h	/^enum TYPE {NF, DR, XX, MP};$/;"	e	enum:TYPE
EXT	include/vfs.h	160;"	d
FAIL	src/devices/tty/shell.c	34;"	d	file:
FILE	include/vfs.h	80;"	d
F_OK	include/vfs.h	87;"	d
IMAP	include/vfs.h	126;"	d
INC_DIR	Makefile	/^INC_DIR        := include\/ framework\/$/;"	m
INIT	src/devices/dev.c	47;"	d	file:
INODE_BYTES	include/vfs.h	122;"	d
INT_MAX	include/kmt.h	13;"	d
INT_MIN	include/kmt.h	14;"	d
ITABLE	include/vfs.h	128;"	d
ITABLE_NUM	include/vfs.h	129;"	d
LENGTH	include/devices.h	5;"	d
LOGBLOCK	include/vfs.h	150;"	d
LOG_NUM	include/vfs.h	149;"	d
Log	include/debug.h	21;"	d
Log	include/debug.h	24;"	d
Log	include/debug.h	28;"	d
LogBlock	src/filesystems/ext2.c	/^void LogBlock(device_t* dev, int x) {$/;"	f
Logcontext	include/debug.h	65;"	d
Logcpu	include/debug.h	18;"	d
Logint	include/debug.h	36;"	d
Logintr	include/debug.h	62;"	d
Loglock	include/debug.h	63;"	d
Lognode	include/debug.h	57;"	d
Logsem	include/debug.h	68;"	d
MAP	src/filesystems/ext2.c	25;"	d	file:
MAXCB	include/os.h	9;"	d
MAXCPU	include/kmt.h	7;"	d
MAXMP	include/vfs.h	60;"	d
MAXTASK	include/kmt.h	12;"	d
MODULE	framework/kernel.h	/^} MODULE(dev);$/;"	t	typeref:struct:__anon4
MODULE	framework/kernel.h	/^} MODULE(kmt);$/;"	t	typeref:struct:__anon3
MODULE	framework/kernel.h	/^} MODULE(os);$/;"	t	typeref:struct:__anon1
MODULE	framework/kernel.h	/^} MODULE(pmm);$/;"	t	typeref:struct:__anon2
MODULE	framework/kernel.h	7;"	d
MODULE	include/vfs.h	/^} MODULE(vfs);$/;"	t	typeref:struct:__anon5
MODULE_DEF	framework/kernel.h	10;"	d
MODULE_DEF	src/devices/dev.c	/^MODULE_DEF(dev) {$/;"	f
MODULE_DEF	src/kmt.c	/^MODULE_DEF(kmt){$/;"	f
MODULE_DEF	src/os.c	/^MODULE_DEF(os){$/;"	f
MODULE_DEF	src/pmm.c	/^MODULE_DEF(pmm) {$/;"	f
MODULE_DEF	src/vfs.c	/^MODULE_DEF(vfs){$/;"	f
MP	include/vfs.h	/^enum TYPE {NF, DR, XX, MP};$/;"	e	enum:TYPE
NAME	Makefile	/^NAME           := kernel$/;"	m
NEVENTS	src/devices/input/input.c	3;"	d	file:
NF	include/vfs.h	/^enum TYPE {NF, DR, XX, MP};$/;"	e	enum:TYPE
NOFILE	include/kmt.h	15;"	d
NSPRITE	src/devices/video/video.c	4;"	d	file:
NTEXTURE	src/devices/video/video.c	3;"	d	file:
OFFSET_BLOCK	include/vfs.h	131;"	d
OFFSET_REMAIN	include/vfs.h	132;"	d
O_CREAT	include/vfs.h	91;"	d
O_RD	include/vfs.h	89;"	d
O_TRUNC	include/vfs.h	92;"	d
O_WR	include/vfs.h	90;"	d
PREBUILD	Makefile	/^PREBUILD := git initrd$/;"	m
Panic	include/debug.h	51;"	d
QEMU_FLAGS	Makefile	/^QEMU_FLAGS := -serial stdio -machine accel=kvm:tcg -drive format=raw,file=$(BINARY)$/;"	m
QEMU_FLAGS_TCG	Makefile	/^QEMU_FLAGS_TCG := -serial stdio -machine accel=tcg -drive format=raw,file=$(BINARY)$/;"	m
RAW	src/vfs.c	78;"	d	file:
RD_SIZE	include/devices.h	36;"	d
R_OK	include/vfs.h	84;"	d
SHOULD_NOT_REACH_HERE	include/debug.h	54;"	d
SPRITE_BRK	include/devices.h	58;"	d
SRCS	Makefile	/^SRCS           := framework\/main.c $(shell find -L .\/src\/ -name "*.c" -o -name "*.S")$/;"	m
STACKSIZE	include/kmt.h	11;"	d
SUCCESS	src/devices/tty/shell.c	33;"	d	file:
S_CUR	include/vfs.h	95;"	d
S_END	include/vfs.h	96;"	d
S_SET	include/vfs.h	94;"	d
TABLE	include/vfs.h	124;"	d
TERM_FONT	include/devices.h	106;"	d
TEXTURE_H	include/devices.h	57;"	d
TEXTURE_W	include/devices.h	56;"	d
TODO	include/debug.h	53;"	d
TTY_COOK_BUF_SZ	src/devices/tty/tty.c	4;"	d	file:
TYPE	include/vfs.h	/^enum TYPE {NF, DR, XX, MP};$/;"	g
Tasknode	include/kmt.h	/^typedef struct Tasknode {$/;"	s
W_OK	include/vfs.h	85;"	d
XX	include/vfs.h	/^enum TYPE {NF, DR, XX, MP};$/;"	e	enum:TYPE
X_OK	include/vfs.h	86;"	d
__COMMON_H__	include/common.h	2;"	d
__DEBUG_H__	include/debug.h	2;"	d
__KERNEL_H__	framework/kernel.h	2;"	d
__KMT_H__	include/kmt.h	2;"	d
__LIST_H__	include/pmm.h	2;"	d
__NANOS_H__	framework/nanos.h	2;"	d
__UTIL_H__	include/util.h	2;"	d
__VFS_H__	include/vfs.h	2;"	d
access	include/vfs.h	/^  int (*access)(const char *path, int mode);$/;"	m	struct:__anon5
add_node	src/pmm.c	/^void *add_node(struct node *p, size_t size) {$/;"	f
alldir	src/util.c	/^char *alldir(const char *path){$/;"	f
alloc	framework/kernel.h	/^  void *(*alloc)(size_t size);$/;"	m	struct:__anon2
alloc_lock	src/pmm.c	/^spinlock_t alloc_lock;$/;"	v
alt	include/devices.h	/^  uint32_t ctrl: 1, alt: 1;$/;"	m	struct:input_event
alt_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon6
assertIF0	include/debug.h	60;"	d
assertIF1	include/debug.h	61;"	d
balloc	src/pmm.c	/^void *balloc(int size){$/;"	f
buf	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
buf	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon9	typeref:struct:__anon9::character
bzero	src/filesystems/ext2.c	/^void bzero(device_t* dev, int x){$/;"	f
callback	include/os.h	/^typedef struct callback {$/;"	s
callback_t	include/os.h	/^} callback_t;$/;"	t	typeref:struct:callback
capslock	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon6
ch	include/devices.h	/^  unsigned char ch;$/;"	m	struct:character
character	include/devices.h	/^struct character {$/;"	s
close	include/vfs.h	/^  int (*close)(file_t *file);$/;"	m	struct:inodeops
close	include/vfs.h	/^  int (*close)(inode_t *inode);$/;"	m	struct:fsops
close	include/vfs.h	/^  int (*close)(int fd);$/;"	m	struct:__anon5
cnt_tasks	include/kmt.h	/^  int count, cnt_tasks;$/;"	m	struct:semaphore
cnt_tasks	src/kmt.c	/^int cnt_tasks;            \/\/ total created tasks$/;"	v
columns	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon9
consumer	framework/L2/test_pc.c	/^void consumer(){$/;"	f
context	include/kmt.h	/^  _Context context;$/;"	m	struct:task
cooked	include/devices.h	/^  sem_t lock, cooked;$/;"	m	struct:__anon9
count	include/kmt.h	/^  int count, cnt_tasks;$/;"	m	struct:semaphore
cpu	include/kmt.h	/^  int cpu;$/;"	m	struct:spinlock
cpudefaulttask	src/kmt.c	/^task_t cpudefaulttask[MAXCPU];$/;"	v
cpuncli	src/kmt.c	/^int cpuncli[MAXCPU], intena[MAXCPU];$/;"	v
cputask	src/kmt.c	/^task_t *cputask[MAXCPU];  \/\/ task running on each cpu$/;"	v
cputask_last	src/kmt.c	/^task_t *cputask_last[MAXCPU];$/;"	v
create	framework/kernel.h	/^  int (*create)(task_t *task, const char *name, void (*entry)(void *arg), void *arg);$/;"	m	struct:__anon3
create	include/vfs.h	/^  int (*create)(filesystem_t *fs, const char *name);$/;"	m	struct:fsops
ctrl	include/devices.h	/^  uint32_t ctrl: 1, alt: 1;$/;"	m	struct:input_event
ctrl_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon6
current	include/devices.h	/^  uint32_t current;$/;"	m	struct:display_info
cursor	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon9	typeref:struct:__anon9::
customer	framework/L2/test_tty_pc.c	/^void customer(void *arg) {$/;"	f
data	include/devices.h	/^  uint32_t data: 16;$/;"	m	struct:input_event
delete_node	src/pmm.c	/^void delete_node(struct node *p) {$/;"	f
dev	include/vfs.h	/^  device_t *dev;$/;"	m	struct:filesystem
dev_create	src/devices/dev.c	/^static device_t *dev_create(size_t dev_size, const char* dev_name, int dev_id, devops_t *dev_ops) {$/;"	f	file:
dev_init	src/devices/dev.c	/^static void dev_init() {$/;"	f	file:
dev_lookup	src/devices/dev.c	/^device_t *dev_lookup(const char *name) {$/;"	f
device	include/devices.h	/^struct device {$/;"	s
device_t	framework/kernel.h	/^typedef struct device device_t;$/;"	t	typeref:struct:device
devices	src/devices/dev.c	/^device_t *devices[0 DEVICES(DEV_CNT)];$/;"	v
devops	framework/kernel.h	/^typedef struct devops {$/;"	s
devops_t	framework/kernel.h	/^} devops_t;$/;"	t	typeref:struct:devops
dir_entry	include/vfs.h	/^struct dir_entry {$/;"	s
dir_entry_t	include/vfs.h	/^typedef struct dir_entry dir_entry_t;$/;"	t	typeref:struct:dir_entry
dir_len	include/vfs.h	/^  uint32_t dir_len; \/\/Special for dir$/;"	m	struct:ext2_inode
dir_len	include/vfs.h	/^  uint32_t dir_len;$/;"	m	struct:inode
dirty	include/devices.h	/^  uint8_t *dirty;$/;"	m	struct:__anon9
display	include/devices.h	/^  device_t *fbdev; int display;$/;"	m	struct:__anon9
display	include/devices.h	/^  unsigned int display: 4;$/;"	m	struct:sprite
display_info	include/devices.h	/^struct display_info {$/;"	s
echo_task	src/devices/tty/tty.c	/^void echo_task(void *name){$/;"	f
empty	framework/L2/test_pc.c	/^sem_t empty, fill;$/;"	v
end	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
end	include/devices.h	/^  char *start, *end;$/;"	m	struct:__anon7
end	include/devices.h	/^  struct character *buf, *end, *cursor;$/;"	m	struct:__anon9	typeref:struct:__anon9::
end	include/pmm.h	/^  uintptr_t start, end;$/;"	m	struct:node
event	include/os.h	/^    int event;$/;"	m	struct:callback
event	src/devices/input/input.c	/^static struct input_event event(int ctrl, int alt, int data) {$/;"	f	file:
event_sem	include/devices.h	/^  sem_t event_sem;$/;"	m	struct:__anon6
events	include/devices.h	/^  struct input_event *events;$/;"	m	struct:__anon6	typeref:struct:__anon6::input_event
exists	include/vfs.h	/^  int exists;$/;"	m	struct:mountpoint
ext2_append_data	include/vfs.h	140;"	d
ext2_close	src/filesystems/ext2ops.c	/^int ext2_close(inode_t *inode){$/;"	f
ext2_create	src/filesystems/ext2ops.c	/^int ext2_create(filesystem_t *fs, const char *name){$/;"	f
ext2_create_dir	include/vfs.h	147;"	d
ext2_create_entry	src/filesystems/ext2.c	/^void ext2_create_entry(device_t *dev, ext2_inode_t* inode, ext2_inode_t* entry_inode, const char* entry_name, uint32_t type){$/;"	f
ext2_create_file	src/filesystems/ext2.c	/^int ext2_create_file(device_t *dev, const char *name, int isroot, int per, int type){$/;"	f
ext2_data_read	src/filesystems/ext2.c	/^ssize_t ext2_data_read(device_t *dev, ext2_inode_t* inode, void *buf, int size, int offset){$/;"	f
ext2_data_write	src/filesystems/ext2.c	/^ssize_t ext2_data_write(device_t *dev, ext2_inode_t* inode, const void *buf, int size, int offset){$/;"	f
ext2_dir_lookup	src/filesystems/ext2.c	/^int ext2_dir_lookup(device_t *dev, ext2_inode_t* inode, const char* name){$/;"	f
ext2_dir_remove	src/filesystems/ext2.c	/^void ext2_dir_remove(device_t *dev, ext2_inode_t* inode, int index){$/;"	f
ext2_init	src/filesystems/ext2ops.c	/^void ext2_init(filesystem_t *fs, const char *name, device_t *dev){$/;"	f
ext2_inode	include/vfs.h	/^struct ext2_inode {$/;"	s
ext2_inode_close	src/filesystems/ext2ops.c	/^int ext2_inode_close(file_t *file){$/;"	f
ext2_inode_create	src/filesystems/ext2.c	/^ext2_inode_t* ext2_inode_create(device_t *dev, uint8_t type, uint8_t per){$/;"	f
ext2_inode_link	src/filesystems/ext2ops.c	/^int ext2_inode_link(file_t *file, const char *name){$/;"	f
ext2_inode_lookup	src/filesystems/ext2.c	/^ext2_inode_t* ext2_inode_lookup(device_t *dev, const char *name){$/;"	f
ext2_inode_lseek	src/filesystems/ext2ops.c	/^off_t ext2_inode_lseek(file_t *file, off_t offset, int whence){$/;"	f
ext2_inode_open	src/filesystems/ext2ops.c	/^int ext2_inode_open(file_t *file, int flags){$/;"	f
ext2_inode_read	src/filesystems/ext2ops.c	/^ssize_t ext2_inode_read(file_t *file, char *buf, size_t size){$/;"	f
ext2_inode_remove	src/filesystems/ext2.c	/^void ext2_inode_remove(device_t *dev, ext2_inode_t* inode){$/;"	f
ext2_inode_t	include/vfs.h	/^typedef struct ext2_inode ext2_inode_t;$/;"	t	typeref:struct:ext2_inode
ext2_inode_write	src/filesystems/ext2ops.c	/^ssize_t ext2_inode_write(file_t *file, const char *buf, size_t size){$/;"	f
ext2_inodeops	src/filesystems/ext2ops.c	/^inodeops_t ext2_inodeops = {$/;"	v
ext2_lookup	src/filesystems/ext2ops.c	/^inode_t* ext2_lookup(filesystem_t *fs, const char *name, int flags){$/;"	f
ext2_mkdir	src/filesystems/ext2ops.c	/^int ext2_mkdir(filesystem_t *fs, const char *name){$/;"	f
ext2_ops	src/filesystems/ext2ops.c	/^fsops_t ext2_ops = {$/;"	v
ext2_rm	src/filesystems/ext2ops.c	/^int ext2_rm(filesystem_t *fs, const char *name){$/;"	f
false	include/common.h	23;"	d
fb_init	src/devices/video/video.c	/^int fb_init(device_t *dev) {$/;"	f
fb_ops	src/devices/video/video.c	/^devops_t fb_ops = {$/;"	v
fb_read	src/devices/video/video.c	/^ssize_t fb_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
fb_sem	src/devices/video/video.c	/^static sem_t fb_sem;$/;"	v	file:
fb_t	include/devices.h	/^} fb_t;$/;"	t	typeref:struct:__anon8
fb_write	src/devices/video/video.c	/^ssize_t fb_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
fbdev	include/devices.h	/^  device_t *fbdev; int display;$/;"	m	struct:__anon9
file	include/vfs.h	/^typedef struct file {$/;"	s
file_t	include/vfs.h	/^} file_t;$/;"	t	typeref:struct:file
file_type	include/vfs.h	/^    uint32_t file_type;$/;"	m	struct:dir_entry
filename	src/util.c	/^char *filename(const char* path){$/;"	f
filesystem	include/vfs.h	/^struct filesystem {$/;"	s
filesystem_t	include/vfs.h	/^typedef struct filesystem filesystem_t;$/;"	t	typeref:struct:filesystem
fill	framework/L2/test_pc.c	/^sem_t empty, fill;$/;"	v
flides	include/kmt.h	/^  file_t *flides[NOFILE];$/;"	m	struct:task
font_default	src/devices/video/fonts/default.c	/^unsigned char font_default[] = {$/;"	v
font_load	src/devices/video/video.c	/^static void font_load(fb_t *fb, uint8_t *font) {$/;"	f	file:
font_sans	src/devices/video/fonts/sans.c	/^unsigned char font_sans[] = {$/;"	v
font_serif	src/devices/video/fonts/serif.c	/^unsigned char font_serif[] = {$/;"	v
free	framework/kernel.h	/^  void (*free)(void *ptr);$/;"	m	struct:__anon2
free_map	src/filesystems/ext2.c	/^int free_map(device_t* dev, int block){$/;"	f
front	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
front	include/devices.h	/^  int front, rear;$/;"	m	struct:__anon6
fs	include/vfs.h	/^  filesystem_t *fs;$/;"	m	struct:inode
fs	include/vfs.h	/^  filesystem_t *fs;$/;"	m	struct:mountpoint
fs_inode	include/vfs.h	/^  void *fs_inode;$/;"	m	struct:inode
fsops	include/vfs.h	/^struct fsops {$/;"	s
fsops_t	include/vfs.h	/^typedef struct fsops fsops_t;$/;"	t	typeref:struct:fsops
get_free_flides	src/vfs.c	/^int get_free_flides(int ccppuu){$/;"	f
get_mount	src/vfs.c	/^static int get_mount(const char *path){$/;"	f	file:
getname	src/devices/tty/shell.c	12;"	d	file:
gettwoname	src/devices/tty/shell.c	19;"	d	file:
gid	src/filesystems/ext2.c	/^uint32_t gid;$/;"	v
h_handlers	src/os.c	/^int h_handlers;$/;"	v
handler	include/os.h	/^    handler_t handler;$/;"	m	struct:callback
handler_t	framework/kernel.h	/^typedef _Context *(*handler_t)(_Event, _Context *);$/;"	t
handlers	src/os.c	/^callback_t handlers[MAXCB];$/;"	v
head	include/pmm.h	/^struct node *head, *tail;$/;"	v	typeref:struct:node
head	src/kmt.c	188;"	d	file:
height	include/devices.h	/^  uint32_t width, height;$/;"	m	struct:display_info
holding	src/kmt.c	/^static int holding(spinlock_t *lock) {$/;"	f	file:
id	include/devices.h	/^  int id;$/;"	m	struct:device
id	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
id	include/vfs.h	/^  uint32_t id; \/\/File id$/;"	m	struct:ext2_inode
id	include/vfs.h	/^  uint32_t id;$/;"	m	struct:inode
index	include/vfs.h	/^  uint32_t index; \/\/index of inode$/;"	m	struct:ext2_inode
info	include/devices.h	/^  struct display_info *info;$/;"	m	struct:__anon8	typeref:struct:__anon8::display_info
init	framework/kernel.h	/^  int (*init)(device_t *dev);$/;"	m	struct:devops
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon1
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon2
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon3
init	framework/kernel.h	/^  void (*init)();$/;"	m	struct:__anon4
init	include/vfs.h	/^  void (*init)();$/;"	m	struct:__anon5
init	include/vfs.h	/^  void (*init)(filesystem_t *fs, const char *name, device_t *dev);$/;"	m	struct:fsops
initialized	src/os.c	/^int initialized = 0;$/;"	v
initialized	src/vfs.c	/^int initialized;$/;"	v
initrd_end	src/devices/ramdisk/initrd.S	/^initrd_end:/;"	l
initrd_start	src/devices/ramdisk/initrd.S	/^initrd_start:$/;"	l
inode	include/vfs.h	/^    uint32_t inode;$/;"	m	struct:dir_entry
inode	include/vfs.h	/^  inode_t *inode;$/;"	m	struct:file
inode	include/vfs.h	/^typedef struct inode {$/;"	s
inode_t	include/vfs.h	/^} inode_t;$/;"	t	typeref:struct:inode
inodeops	include/vfs.h	/^struct inodeops {$/;"	s
inodeops_t	include/vfs.h	/^typedef struct inodeops inodeops_t;$/;"	t	typeref:struct:inodeops
input_event	include/devices.h	/^struct input_event {$/;"	s
input_init	src/devices/input/input.c	/^static int input_init(device_t *dev) {$/;"	f	file:
input_keydown	src/devices/input/input.c	/^void input_keydown(device_t *dev, int code) {$/;"	f
input_notify	src/devices/input/input.c	/^static _Context *input_notify(_Event ev, _Context *context) {$/;"	f	file:
input_ops	src/devices/input/input.c	/^devops_t input_ops = {$/;"	v
input_read	src/devices/input/input.c	/^static ssize_t input_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f	file:
input_t	include/devices.h	/^} input_t;$/;"	t	typeref:struct:__anon6
input_task	src/devices/input/input.c	/^void input_task(void *args) {$/;"	f
input_write	src/devices/input/input.c	/^static ssize_t input_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f	file:
intena	src/kmt.c	/^int cpuncli[MAXCPU], intena[MAXCPU];$/;"	v
isdigit	src/devices/tty/shell.c	/^static int isdigit(int ch){return (ch>='0')&&(ch<='9');}$/;"	f	file:
kalloc	src/pmm.c	/^static void *kalloc(size_t size) {$/;"	f	file:
keymap	src/devices/input/keymaps.c	/^char keymap[256] = {$/;"	v
keymap_shift	src/devices/input/keymaps.c	/^char keymap_shift[256] = {$/;"	v
kfree	src/pmm.c	/^static void kfree(void *ptr) {$/;"	f	file:
kmt_context_save	src/kmt.c	/^_Context *kmt_context_save(_Event ev, _Context *context) {$/;"	f
kmt_context_switch	src/kmt.c	/^_Context *kmt_context_switch(_Event ev, _Context *context) {$/;"	f
kmt_create	src/kmt.c	/^int kmt_create(task_t *task, const char *name, void (*entry)(void *arg),$/;"	f
kmt_init	src/kmt.c	/^void kmt_init() {$/;"	f
kmt_teardown	src/kmt.c	/^void kmt_teardown(task_t *task) {$/;"	f
len	include/vfs.h	/^  uint32_t len; \/\/Number of link$/;"	m	struct:ext2_inode
lines	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon9
link	include/vfs.h	/^  int (*link)(const char *oldpath, const char *newpath);$/;"	m	struct:__anon5
link	include/vfs.h	/^  int (*link)(file_t *file, const char*name);$/;"	m	struct:inodeops
link	include/vfs.h	/^  uint32_t link[25];$/;"	m	struct:ext2_inode
link_num	include/vfs.h	/^  uint32_t link_num;$/;"	m	struct:ext2_inode
link_num	include/vfs.h	/^  uint32_t link_num;$/;"	m	struct:inode
list_init	src/pmm.c	/^void list_init(uintptr_t pm_start, uintptr_t pm_end) {$/;"	f
lock	include/devices.h	/^  sem_t lock, cooked;$/;"	m	struct:__anon9
lock	include/devices.h	/^  spinlock_t lock;$/;"	m	struct:__anon6
lock	include/kmt.h	/^  spinlock_t lock;$/;"	m	struct:semaphore
lock_debug	src/os.c	/^spinlock_t lock_debug;$/;"	v
lock_kmt	src/kmt.c	/^spinlock_t lock_kmt;$/;"	v
lock_os	src/os.c	/^spinlock_t lock_os;$/;"	v
lock_print	src/os.c	/^spinlock_t lock_print;$/;"	v
locked	include/kmt.h	/^  int locked;$/;"	m	struct:spinlock
logging	framework/L2/test_abc.c	/^void logging(void *arg) {$/;"	f
logging	framework/L2/test_gen.c	/^void logging(void *arg) {$/;"	f
lookup	include/vfs.h	/^  inode_t *(*lookup)(filesystem_t *fs, const char *name, int flags);$/;"	m	struct:fsops
lprintf	include/common.h	15;"	d
lseek	include/vfs.h	/^  off_t (*lseek)(file_t *file, off_t offset, int whence);$/;"	m	struct:inodeops
lseek	include/vfs.h	/^  off_t (*lseek)(int fd, off_t offset, int whence);$/;"	m	struct:__anon5
main	framework/L2/test_abc.c	/^int main() {$/;"	f
main	framework/L2/test_gen.c	/^int main() {$/;"	f
main	framework/L2/test_pc.c	/^int main() {$/;"	f
main	framework/L2/test_tty.c	/^int main() {$/;"	f
main	framework/L2/test_tty_pc.c	/^int main() {$/;"	f
main	framework/L2/test_yield.c	/^int main() {$/;"	f
main	framework/main.c	/^int main() {$/;"	f
max	include/common.h	24;"	d
metadata	include/devices.h	/^  uint32_t metadata;$/;"	m	struct:character
min	include/common.h	25;"	d
mkdir	include/vfs.h	/^  int (*mkdir)(const char *path);$/;"	m	struct:__anon5
mkdir	include/vfs.h	/^  int (*mkdir)(filesystem_t *fs, const char *name);$/;"	m	struct:fsops
modify	src/devices/tty/shell.c	5;"	d	file:
mount	include/vfs.h	/^  int (*mount)(const char *path, filesystem_t *fs);$/;"	m	struct:__anon5
mountpoint	include/vfs.h	/^typedef struct mountpoint {$/;"	s
mountpoint_t	include/vfs.h	/^} mountpoint_t;$/;"	t	typeref:struct:mountpoint
mp	src/filesystems/ext2.c	/^const  char *mp = "\/";$/;"	v
mpt	src/vfs.c	/^mountpoint_t mpt[MAXMP];$/;"	v
mutex	framework/L2/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
my_atoi	src/devices/tty/shell.c	/^static int my_atoi(char *s){$/;"	f	file:
name	include/devices.h	/^  const char *name;$/;"	m	struct:device
name	include/kmt.h	/^  const char *name;$/;"	m	struct:semaphore
name	include/kmt.h	/^  const char *name;$/;"	m	struct:spinlock
name	include/kmt.h	/^  const char *name;$/;"	m	struct:task
name_len	include/vfs.h	/^    uint32_t name_len;$/;"	m	struct:dir_entry
next	include/pmm.h	/^  struct node *next, *pre;$/;"	m	struct:node	typeref:struct:node::node
node	include/pmm.h	/^struct node {$/;"	s
non	framework/L2/test_yield.c	/^void non(){$/;"	f
notdefault	src/kmt.c	/^int notdefault[MAXCPU];$/;"	v
num_displays	include/devices.h	/^  uint32_t num_displays;$/;"	m	struct:display_info
num_sprites	include/devices.h	/^  uint32_t num_textures, num_sprites;$/;"	m	struct:display_info
num_textures	include/devices.h	/^  uint32_t num_textures, num_sprites;$/;"	m	struct:display_info
nxt	include/kmt.h	/^  struct Tasknode *nxt, *pre;$/;"	m	struct:Tasknode	typeref:struct:Tasknode::Tasknode
off_t	framework/nanos.h	/^typedef intptr_t off_t;$/;"	t
offset	include/vfs.h	/^  uint64_t offset;$/;"	m	struct:file
on_irq	framework/kernel.h	/^  void (*on_irq)(int seq, int event, handler_t handler);$/;"	m	struct:__anon1
open	include/vfs.h	/^  int (*open)(const char *path, int flags);$/;"	m	struct:__anon5
open	include/vfs.h	/^  int (*open)(file_t *file, int flags);$/;"	m	struct:inodeops
ops	include/devices.h	/^  devops_t *ops;$/;"	m	struct:device
ops	include/vfs.h	/^  fsops_t *ops;$/;"	m	struct:filesystem
ops	include/vfs.h	/^  inodeops_t *ops;$/;"	m	struct:inode
os_init	src/os.c	/^static void os_init() {$/;"	f	file:
os_on_irq	src/os.c	/^static void os_on_irq(int seq, int event, handler_t handler) {$/;"	f	file:
os_run	src/os.c	/^static void os_run() {$/;"	f	file:
os_trap	src/os.c	/^static _Context *os_trap(_Event ev, _Context *context) {$/;"	f	file:
panic	include/devices.h	/^static inline void panic(const char *s) { printf("%s\\n", s); _halt(1); }$/;"	f
path	include/vfs.h	/^  const char *path;$/;"	m	struct:mountpoint
pcb	include/kmt.h	/^  tasknode_t *pcb;$/;"	m	struct:semaphore
permission	include/vfs.h	/^  uint16_t permission; \/\/Permission of this inode$/;"	m	struct:ext2_inode
permission	include/vfs.h	/^  uint16_t permission;$/;"	m	struct:inode
pid_t	framework/nanos.h	/^typedef int32_t pid_t;$/;"	t
pixels	include/devices.h	/^  uint32_t pixels[TEXTURE_W * TEXTURE_H];$/;"	m	struct:texture
pm_end	src/pmm.c	/^static uintptr_t pm_start, pm_end;$/;"	v	file:
pm_start	src/pmm.c	/^static uintptr_t pm_start, pm_end;$/;"	v	file:
pmm_init	src/pmm.c	/^static void pmm_init() {$/;"	f	file:
pop_event	src/devices/input/input.c	/^static struct input_event pop_event(input_t *in) {$/;"	f	file:
popcli	src/kmt.c	/^static void popcli(void) {$/;"	f	file:
postname	src/util.c	/^char *postname(const char *path){$/;"	f
pre	include/kmt.h	/^  struct Tasknode *nxt, *pre;$/;"	m	struct:Tasknode	typeref:struct:Tasknode::
pre	include/pmm.h	/^  struct node *next, *pre;$/;"	m	struct:node	typeref:struct:node::
producer	framework/L2/test_pc.c	/^void producer(){$/;"	f
producer	framework/L2/test_tty_pc.c	/^void producer(void *arg) {$/;"	f
ptr	include/devices.h	/^  void *ptr;$/;"	m	struct:device
push_event	src/devices/input/input.c	/^static void push_event(input_t *in, struct input_event ev) {$/;"	f	file:
pushcli	src/kmt.c	/^static void pushcli(void) {$/;"	f	file:
queue	include/devices.h	/^  struct tty_queue queue;$/;"	m	struct:__anon9	typeref:struct:__anon9::tty_queue
rd_init	src/devices/ramdisk/ramdisk.c	/^int rd_init(device_t *dev) {$/;"	f
rd_ops	src/devices/ramdisk/ramdisk.c	/^devops_t rd_ops = {$/;"	v
rd_read	src/devices/ramdisk/ramdisk.c	/^ssize_t rd_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
rd_t	include/devices.h	/^} rd_t;$/;"	t	typeref:struct:__anon7
rd_write	src/devices/ramdisk/ramdisk.c	/^ssize_t rd_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
read	framework/kernel.h	/^  ssize_t (*read)(device_t *dev, off_t offset, void *buf, size_t count);$/;"	m	struct:devops
read	include/vfs.h	/^  ssize_t (*read)(file_t *file, char *buf, size_t size);$/;"	m	struct:inodeops
read	include/vfs.h	/^  ssize_t (*read)(int fd, void *buf, size_t nbyte);$/;"	m	struct:__anon5
read_map	src/filesystems/ext2.c	/^int read_map(device_t *dev, int block, int i){$/;"	f
rear	include/devices.h	/^  char *buf, *end, *front, *rear;$/;"	m	struct:tty_queue
rear	include/devices.h	/^  int front, rear;$/;"	m	struct:__anon6
rec_len	include/vfs.h	/^    uint32_t rec_len;$/;"	m	struct:dir_entry
rmdir	include/vfs.h	/^  int (*rmdir)(const char *path);$/;"	m	struct:__anon5
rmdir	include/vfs.h	/^  int (*rmdir)(filesystem_t *fs, const char *name);$/;"	m	struct:fsops
rootdir	src/util.c	/^char *rootdir(const char* path){$/;"	f
run	framework/kernel.h	/^  void (*run)();$/;"	m	struct:__anon1
run	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
sem_c	framework/L2/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
sem_init	framework/kernel.h	/^  void (*sem_init)(sem_t *sem, const char *name, int value);$/;"	m	struct:__anon3
sem_init	src/kmt.c	/^void sem_init(sem_t *sem, const char *name, int value) {$/;"	f
sem_kbdirq	src/devices/input/input.c	/^sem_t sem_kbdirq;$/;"	v
sem_list_add	src/kmt.c	/^void sem_list_add(sem_t *sem, task_t *task) {$/;"	f
sem_list_delete	src/kmt.c	/^void sem_list_delete(sem_t *sem) {$/;"	f
sem_p	framework/L2/test_tty_pc.c	/^sem_t sem_p, sem_c, mutex;$/;"	v
sem_signal	framework/kernel.h	/^  void (*sem_signal)(sem_t *sem);$/;"	m	struct:__anon3
sem_signal	src/kmt.c	/^void sem_signal(sem_t *sem) {$/;"	f
sem_t	framework/kernel.h	/^typedef struct semaphore sem_t;$/;"	t	typeref:struct:semaphore
sem_wait	framework/kernel.h	/^  void (*sem_wait)(sem_t *sem);$/;"	m	struct:__anon3
sem_wait	src/kmt.c	/^void sem_wait(sem_t *sem) {$/;"	f
semaphore	include/kmt.h	/^struct semaphore {$/;"	s
seq	include/os.h	/^    int seq;$/;"	m	struct:callback
shell_task	src/devices/tty/shell.c	/^void shell_task(void *name){$/;"	f
shift_down	include/devices.h	/^  int capslock, shift_down[2], ctrl_down[2], alt_down[2];$/;"	m	struct:__anon6
size	include/devices.h	/^  int lines, columns, size;$/;"	m	struct:__anon9
size	include/vfs.h	/^  uint32_t size; \/\/Size of file$/;"	m	struct:ext2_inode
size	include/vfs.h	/^  uint32_t size;$/;"	m	struct:inode
sleep	include/kmt.h	/^  int run, id, sleep;$/;"	m	struct:task
spin_init	framework/kernel.h	/^  void (*spin_init)(spinlock_t *lk, const char *name);$/;"	m	struct:__anon3
spin_init	src/kmt.c	/^void spin_init(spinlock_t *lk, const char *name) {$/;"	f
spin_lock	framework/kernel.h	/^  void (*spin_lock)(spinlock_t *lk);$/;"	m	struct:__anon3
spin_lock	src/kmt.c	/^void spin_lock(spinlock_t *lk) {$/;"	f
spin_unlock	framework/kernel.h	/^  void (*spin_unlock)(spinlock_t *lk);$/;"	m	struct:__anon3
spin_unlock	src/kmt.c	/^void spin_unlock(spinlock_t *lk) {$/;"	f
spinlock	include/kmt.h	/^struct spinlock {$/;"	s
spinlock_t	framework/kernel.h	/^typedef struct spinlock spinlock_t;$/;"	t	typeref:struct:spinlock
sprite	include/devices.h	/^struct sprite {$/;"	s
sprites	include/devices.h	/^  struct sprite *sprites;$/;"	m	struct:__anon8	typeref:struct:__anon8::sprite
ssize_t	framework/nanos.h	/^typedef intptr_t ssize_t;$/;"	t
stack	include/kmt.h	/^  char* stack;$/;"	m	struct:task
start	include/devices.h	/^  char *start, *end;$/;"	m	struct:__anon7
start	include/pmm.h	/^  uintptr_t start, end;$/;"	m	struct:node
start	src/pmm.c	/^static uintptr_t start;$/;"	v	file:
str	framework/L2/test_gen.c	/^char* str[] = {"1", "2", "3", "4"};$/;"	v
strip	src/util.c	/^void strip(char *tmp){$/;"	f
tail	include/pmm.h	/^struct node *head, *tail;$/;"	v	typeref:struct:
task	include/kmt.h	/^  task_t *task;$/;"	m	struct:Tasknode
task	include/kmt.h	/^struct task {$/;"	s
task_t	framework/kernel.h	/^typedef struct task task_t;$/;"	t	typeref:struct:task
tasknode_t	include/kmt.h	/^} tasknode_t;$/;"	t	typeref:struct:Tasknode
tasks	src/kmt.c	/^task_t *tasks[MAXTASK];$/;"	v
teardown	framework/kernel.h	/^  void (*teardown)(task_t *task);$/;"	m	struct:__anon3
test	framework/L2/test_gen.c	/^void test(void *arg){$/;"	f
texture	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
texture	include/devices.h	/^struct texture {$/;"	s
texture_fill	src/devices/video/video.c	/^static void texture_fill(struct texture *tx, int top, uint8_t *bits, uint32_t fg, uint32_t bg) {$/;"	f	file:
textures	include/devices.h	/^  struct texture *textures;$/;"	m	struct:__anon8	typeref:struct:__anon8::texture
trap	framework/kernel.h	/^  _Context *(*trap)(_Event ev, _Context *context);$/;"	m	struct:__anon1
true	include/common.h	22;"	d
tty_cook	src/devices/tty/tty.c	/^static int tty_cook(tty_t *tty, char ch) {$/;"	f	file:
tty_defaultch	src/devices/tty/tty.c	/^struct character tty_defaultch() {$/;"	f
tty_enqueue	src/devices/tty/tty.c	/^static void tty_enqueue(struct tty_queue *q, char ch) {$/;"	f	file:
tty_init	src/devices/tty/tty.c	/^int tty_init(device_t *dev) {$/;"	f
tty_mark	src/devices/tty/tty.c	/^static void tty_mark(tty_t *tty, struct character *ch) {$/;"	f	file:
tty_mark_all	src/devices/tty/tty.c	/^static void tty_mark_all(tty_t *tty) {$/;"	f	file:
tty_mark_line	src/devices/tty/tty.c	/^static void tty_mark_line(tty_t *tty, struct character *ch) {$/;"	f	file:
tty_ops	src/devices/tty/tty.c	/^devops_t tty_ops = {$/;"	v
tty_pop_back	src/devices/tty/tty.c	/^static int tty_pop_back(struct tty_queue *q) {$/;"	f	file:
tty_putc	src/devices/tty/tty.c	/^static void tty_putc(tty_t *tty, char ch) {$/;"	f	file:
tty_queue	include/devices.h	/^struct tty_queue {$/;"	s
tty_read	src/devices/tty/tty.c	/^ssize_t tty_read(device_t *dev, off_t offset, void *buf, size_t count) {$/;"	f
tty_render	src/devices/tty/tty.c	/^static void tty_render(tty_t *tty) {$/;"	f	file:
tty_t	include/devices.h	/^} tty_t;$/;"	t	typeref:struct:__anon9
tty_task	src/devices/tty/tty.c	/^void tty_task(void *arg) {$/;"	f
tty_upd_backsp	src/devices/tty/tty.c	/^static inline void tty_upd_backsp(tty_t *tty) {$/;"	f	file:
tty_upd_cr	src/devices/tty/tty.c	/^static inline void tty_upd_cr(tty_t *tty) {$/;"	f	file:
tty_upd_lf	src/devices/tty/tty.c	/^static inline void tty_upd_lf(tty_t *tty) {$/;"	f	file:
tty_upd_putc	src/devices/tty/tty.c	/^static inline void tty_upd_putc(tty_t *tty, char ch) {$/;"	f	file:
tty_upd_scrollup	src/devices/tty/tty.c	/^static void tty_upd_scrollup(tty_t *tty) {$/;"	f	file:
tty_write	src/devices/tty/tty.c	/^ssize_t tty_write(device_t *dev, off_t offset, const void *buf, size_t count) {$/;"	f
type	include/vfs.h	/^  uint16_t type; \/\/Type of this inode$/;"	m	struct:ext2_inode
type	include/vfs.h	/^  uint32_t type;$/;"	m	struct:inode
uint	include/debug.h	/^typedef unsigned int uint;$/;"	t
unlink	include/vfs.h	/^  int (*unlink)(const char *path);$/;"	m	struct:__anon5
unlink	include/vfs.h	/^  int (*unlink)(filesystem_t *fs, const char *name);$/;"	m	struct:fsops
unmount	include/vfs.h	/^  int (*unmount)(const char *path);$/;"	m	struct:__anon5
update_inode	src/filesystems/ext2ops.c	/^void update_inode(inode_t* inode, ext2_inode_t *extinode){$/;"	f
update_inode_attr	src/filesystems/ext2ops.c	17;"	d	file:
vfs_access	src/vfs.c	/^int vfs_access(const char *path, int mode){$/;"	f
vfs_close	src/vfs.c	/^int vfs_close(int fd){$/;"	f
vfs_init	src/vfs.c	/^void vfs_init(){$/;"	f
vfs_link	src/vfs.c	/^int vfs_link(const char *oldpath, const char *newpath){$/;"	f
vfs_lseek	src/vfs.c	/^off_t vfs_lseek(int fd, off_t offset, int whence){$/;"	f
vfs_mkdir	src/vfs.c	/^int vfs_mkdir(const char *path){$/;"	f
vfs_mount	src/vfs.c	/^int vfs_mount(const char *path, filesystem_t *fs){$/;"	f
vfs_open	src/vfs.c	/^int vfs_open(const char *path, int flags){$/;"	f
vfs_read	src/vfs.c	/^ssize_t vfs_read(int fd, void *buf, size_t nbyte){$/;"	f
vfs_rmdir	src/vfs.c	/^int vfs_rmdir(const char *path){$/;"	f
vfs_unlink	src/vfs.c	/^int vfs_unlink(const char *path){$/;"	f
vfs_unmount	src/vfs.c	/^int vfs_unmount(const char *path){$/;"	f
vfs_write	src/vfs.c	/^ssize_t vfs_write(int fd, const void *buf, size_t nbyte){$/;"	f
warning	include/common.h	19;"	d
width	include/devices.h	/^  uint32_t width, height;$/;"	m	struct:display_info
write	framework/kernel.h	/^  ssize_t (*write)(device_t *dev, off_t offset, const void *buf, size_t count);$/;"	m	struct:devops
write	include/vfs.h	/^  ssize_t (*write)(file_t *file, const char *buf, size_t size);$/;"	m	struct:inodeops
write	include/vfs.h	/^  ssize_t (*write)(int fd, const void *buf, size_t nbyte);$/;"	m	struct:__anon5
write_map	src/filesystems/ext2.c	/^int write_map(device_t* dev, int block, int i, uint8_t x){$/;"	f
x	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
y	include/devices.h	/^  uint16_t texture, x, y;$/;"	m	struct:sprite
z	include/devices.h	/^  unsigned int z: 12;$/;"	m	struct:sprite
